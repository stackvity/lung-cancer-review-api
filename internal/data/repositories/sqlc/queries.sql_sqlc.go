// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalysisResult = `-- name: CreateAnalysisResult :one

INSERT INTO analysisresult (session_id, diagnosis, stage, treatment_recommendations)
VALUES ($1, $2, $3, $4)
RETURNING result_id, session_id, diagnosis, stage, treatment_recommendations, created_at, updated_at
`

type CreateAnalysisResultParams struct {
	SessionID                pgtype.UUID `json:"session_id"`
	Diagnosis                []byte      `json:"diagnosis"`
	Stage                    []byte      `json:"stage"`
	TreatmentRecommendations []byte      `json:"treatment_recommendations"`
}

// ------------- AnalysisResult Queries -------------
// CreateAnalysisResult: Inserts a new analysis result record.
func (q *Queries) CreateAnalysisResult(ctx context.Context, db DBTX, arg *CreateAnalysisResultParams) (*Analysisresult, error) {
	row := db.QueryRow(ctx, createAnalysisResult,
		arg.SessionID,
		arg.Diagnosis,
		arg.Stage,
		arg.TreatmentRecommendations,
	)
	var i Analysisresult
	err := row.Scan(
		&i.ResultID,
		&i.SessionID,
		&i.Diagnosis,
		&i.Stage,
		&i.TreatmentRecommendations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createAnalysisResultExternalResource = `-- name: CreateAnalysisResultExternalResource :exec
INSERT INTO analysisresultexternalresource (result_id, resource_id)
VALUES ($1, $2)
`

type CreateAnalysisResultExternalResourceParams struct {
	ResultID   pgtype.UUID `json:"result_id"`
	ResourceID int32       `json:"resource_id"`
}

// CreateAnalysisResultExternalResource: Links an analysis result to an external resource.
func (q *Queries) CreateAnalysisResultExternalResource(ctx context.Context, db DBTX, arg *CreateAnalysisResultExternalResourceParams) error {
	_, err := db.Exec(ctx, createAnalysisResultExternalResource, arg.ResultID, arg.ResourceID)
	return err
}

const createAuditLog = `-- name: CreateAuditLog :one

INSERT INTO auditlog (session_id, content_id, result_id, action, details)
VALUES ($1, $2, $3, $4, $5)
RETURNING log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at
`

type CreateAuditLogParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	ContentID pgtype.UUID `json:"content_id"`
	ResultID  pgtype.UUID `json:"result_id"`
	Action    string      `json:"action"`
	Details   []byte      `json:"details"`
}

// ------------- AuditLog Queries -------------
// CreateAuditLog: Inserts a new audit log entry.
func (q *Queries) CreateAuditLog(ctx context.Context, db DBTX, arg *CreateAuditLogParams) (*Auditlog, error) {
	row := db.QueryRow(ctx, createAuditLog,
		arg.SessionID,
		arg.ContentID,
		arg.ResultID,
		arg.Action,
		arg.Details,
	)
	var i Auditlog
	err := row.Scan(
		&i.LogID,
		&i.Timestamp,
		&i.Action,
		&i.Details,
		&i.SessionID,
		&i.ContentID,
		&i.ResultID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createDiagnosis = `-- name: CreateDiagnosis :one

INSERT INTO diagnosis (result_id, session_id, diagnosis_text, confidence, justification)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, result_id, session_id, diagnosis_text, confidence, justification, created_at, updated_at
`

type CreateDiagnosisParams struct {
	ResultID      pgtype.UUID `json:"result_id"`
	SessionID     pgtype.UUID `json:"session_id"`
	DiagnosisText pgtype.Text `json:"diagnosis_text"`
	Confidence    pgtype.Text `json:"confidence"`
	Justification pgtype.Text `json:"justification"`
}

// ------------- Diagnosis Queries -------------
// CreateDiagnosis inserts a new diagnosis record.
func (q *Queries) CreateDiagnosis(ctx context.Context, db DBTX, arg *CreateDiagnosisParams) (*Diagnosis, error) {
	row := db.QueryRow(ctx, createDiagnosis,
		arg.ResultID,
		arg.SessionID,
		arg.DiagnosisText,
		arg.Confidence,
		arg.Justification,
	)
	var i Diagnosis
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.DiagnosisText,
		&i.Confidence,
		&i.Justification,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createExternalResource = `-- name: CreateExternalResource :one

INSERT INTO externalresource (name, url, description)
VALUES ($1, $2, $3)
RETURNING resource_id, name, url, description
`

type CreateExternalResourceParams struct {
	Name        string      `json:"name"`
	Url         string      `json:"url"`
	Description pgtype.Text `json:"description"`
}

// ------------- ExternalResource Queries -------------
// These don't interact with patient data directly, so they are less sensitive.
// CreateExternalResource: Inserts a new external resource.
func (q *Queries) CreateExternalResource(ctx context.Context, db DBTX, arg *CreateExternalResourceParams) (*Externalresource, error) {
	row := db.QueryRow(ctx, createExternalResource, arg.Name, arg.Url, arg.Description)
	var i Externalresource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Url,
		&i.Description,
	)
	return &i, err
}

const createFinding = `-- name: CreateFinding :one
INSERT INTO findings (finding_id, file_id, finding_type, description, image_coordinates, source)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING finding_id, file_id, finding_type, description, image_coordinates, source, created_at, updated_at
`

type CreateFindingParams struct {
	FindingID        pgtype.UUID `json:"finding_id"`
	FileID           pgtype.UUID `json:"file_id"`
	FindingType      string      `json:"finding_type"`
	Description      string      `json:"description"`
	ImageCoordinates []float64   `json:"image_coordinates"`
	Source           string      `json:"source"`
}

// CreateFinding inserts a new finding record.
func (q *Queries) CreateFinding(ctx context.Context, db DBTX, arg *CreateFindingParams) (*Finding, error) {
	row := db.QueryRow(ctx, createFinding,
		arg.FindingID,
		arg.FileID,
		arg.FindingType,
		arg.Description,
		arg.ImageCoordinates,
		arg.Source,
	)
	var i Finding
	err := row.Scan(
		&i.FindingID,
		&i.FileID,
		&i.FindingType,
		&i.Description,
		&i.ImageCoordinates,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createImage = `-- name: CreateImage :one

INSERT INTO images (id, study_id, file_path, series_instance_uid, sop_instance_uid, image_type, content_data)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, study_id, file_path, series_instance_uid, sop_instance_uid, image_type, content_data, created_at, updated_at
`

type CreateImageParams struct {
	ID                pgtype.UUID `json:"id"`
	StudyID           pgtype.UUID `json:"study_id"`
	FilePath          string      `json:"file_path"`
	SeriesInstanceUid string      `json:"series_instance_uid"`
	SopInstanceUid    string      `json:"sop_instance_uid"`
	ImageType         string      `json:"image_type"`
	ContentData       []byte      `json:"content_data"`
}

// ------------- Image Queries -------------
// CreateImage creates a new image
func (q *Queries) CreateImage(ctx context.Context, db DBTX, arg *CreateImageParams) (*Image, error) {
	row := db.QueryRow(ctx, createImage,
		arg.ID,
		arg.StudyID,
		arg.FilePath,
		arg.SeriesInstanceUid,
		arg.SopInstanceUid,
		arg.ImageType,
		arg.ContentData,
	)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.StudyID,
		&i.FilePath,
		&i.SeriesInstanceUid,
		&i.SopInstanceUid,
		&i.ImageType,
		&i.ContentData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createPatientSession = `-- name: CreatePatientSession :one

INSERT INTO patientsession (access_link, expiration_timestamp, used, patient_data)
VALUES ($1, $2, $3, $4)
RETURNING session_id, access_link, expiration_timestamp, used, patient_data, created_at, updated_at
`

type CreatePatientSessionParams struct {
	AccessLink          string             `json:"access_link"`
	ExpirationTimestamp pgtype.Timestamptz `json:"expiration_timestamp"`
	Used                bool               `json:"used"`
	PatientData         []byte             `json:"patient_data"`
}

// ------------- PatientSession (and Link) Queries -------------
// CreatePatientSession: Creates a new patient session (with associated link).
func (q *Queries) CreatePatientSession(ctx context.Context, db DBTX, arg *CreatePatientSessionParams) (*Patientsession, error) {
	row := db.QueryRow(ctx, createPatientSession,
		arg.AccessLink,
		arg.ExpirationTimestamp,
		arg.Used,
		arg.PatientData,
	)
	var i Patientsession
	err := row.Scan(
		&i.SessionID,
		&i.AccessLink,
		&i.ExpirationTimestamp,
		&i.Used,
		&i.PatientData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createPrompt = `-- name: CreatePrompt :one

INSERT INTO prompts (description, template, input_variables, output_format, version, author, status, approval_status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING prompt_id, description, template, input_variables, output_format, version, author, status, approval_status, created_at, updated_at
`

type CreatePromptParams struct {
	Description    pgtype.Text `json:"description"`
	Template       string      `json:"template"`
	InputVariables pgtype.Text `json:"input_variables"`
	OutputFormat   pgtype.Text `json:"output_format"`
	Version        string      `json:"version"`
	Author         pgtype.Text `json:"author"`
	Status         string      `json:"status"`
	ApprovalStatus pgtype.Text `json:"approval_status"`
}

// ------------- Prompt Queries -------------
// CreatePrompt: Inserts a new prompt.
func (q *Queries) CreatePrompt(ctx context.Context, db DBTX, arg *CreatePromptParams) (*Prompt, error) {
	row := db.QueryRow(ctx, createPrompt,
		arg.Description,
		arg.Template,
		arg.InputVariables,
		arg.OutputFormat,
		arg.Version,
		arg.Author,
		arg.Status,
		arg.ApprovalStatus,
	)
	var i Prompt
	err := row.Scan(
		&i.PromptID,
		&i.Description,
		&i.Template,
		&i.InputVariables,
		&i.OutputFormat,
		&i.Version,
		&i.Author,
		&i.Status,
		&i.ApprovalStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createReport = `-- name: CreateReport :one

INSERT INTO reports (id, patient_id, filename, report_type, report_text, filepath)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, patient_id, filename, report_type, report_text, filepath, created_at, updated_at
`

type CreateReportParams struct {
	ID         pgtype.UUID `json:"id"`
	PatientID  pgtype.UUID `json:"patient_id"`
	Filename   string      `json:"filename"`
	ReportType ReportType  `json:"report_type"`
	ReportText pgtype.Text `json:"report_text"`
	Filepath   string      `json:"filepath"`
}

// ------------- Report Queries -------------
// CreateReport inserts a new report record.
func (q *Queries) CreateReport(ctx context.Context, db DBTX, arg *CreateReportParams) (*Report, error) {
	row := db.QueryRow(ctx, createReport,
		arg.ID,
		arg.PatientID,
		arg.Filename,
		arg.ReportType,
		arg.ReportText,
		arg.Filepath,
	)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Filename,
		&i.ReportType,
		&i.ReportText,
		&i.Filepath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createStaging = `-- name: CreateStaging :one

INSERT INTO stages (result_id, session_id, t, n, m, confidence)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, result_id, session_id, t, n, m, confidence, created_at, updated_at
`

type CreateStagingParams struct {
	ResultID   pgtype.UUID `json:"result_id"`
	SessionID  pgtype.UUID `json:"session_id"`
	T          pgtype.Text `json:"t"`
	N          pgtype.Text `json:"n"`
	M          pgtype.Text `json:"m"`
	Confidence pgtype.Text `json:"confidence"`
}

// ------------- Stage Queries -------------
// CreateStaging inserts a new staging record.
func (q *Queries) CreateStaging(ctx context.Context, db DBTX, arg *CreateStagingParams) (*Stage, error) {
	row := db.QueryRow(ctx, createStaging,
		arg.ResultID,
		arg.SessionID,
		arg.T,
		arg.N,
		arg.M,
		arg.Confidence,
	)
	var i Stage
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.T,
		&i.N,
		&i.M,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createStudy = `-- name: CreateStudy :one

INSERT INTO studies (id, patient_id, study_instance_uid, study_data)
VALUES ($1, $2, $3, $4)
RETURNING id, patient_id, study_instance_uid, study_data, created_at, updated_at
`

type CreateStudyParams struct {
	ID               pgtype.UUID `json:"id"`
	PatientID        pgtype.UUID `json:"patient_id"`
	StudyInstanceUid string      `json:"study_instance_uid"`
	StudyData        []byte      `json:"study_data"`
}

// ------------- Study Queries -------------
// CreateStudy creates a new study
func (q *Queries) CreateStudy(ctx context.Context, db DBTX, arg *CreateStudyParams) (*Study, error) {
	row := db.QueryRow(ctx, createStudy,
		arg.ID,
		arg.PatientID,
		arg.StudyInstanceUid,
		arg.StudyData,
	)
	var i Study
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.StudyInstanceUid,
		&i.StudyData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createTreatmentRecommendation = `-- name: CreateTreatmentRecommendation :one

INSERT INTO treatmentrecommendations (result_id, session_id, diagnosis_id, treatment_option, rationale, benefits, risks, side_effects, confidence)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, result_id, session_id, diagnosis_id, treatment_option, rationale, benefits, risks, side_effects, confidence, created_at, updated_at
`

type CreateTreatmentRecommendationParams struct {
	ResultID        pgtype.UUID `json:"result_id"`
	SessionID       pgtype.UUID `json:"session_id"`
	DiagnosisID     pgtype.UUID `json:"diagnosis_id"`
	TreatmentOption pgtype.Text `json:"treatment_option"`
	Rationale       pgtype.Text `json:"rationale"`
	Benefits        pgtype.Text `json:"benefits"`
	Risks           pgtype.Text `json:"risks"`
	SideEffects     pgtype.Text `json:"side_effects"`
	Confidence      pgtype.Text `json:"confidence"`
}

// ------------- TreatmentRecommendation Queries -------------
// CreateTreatmentRecommendation inserts a new treatment recommendation record.
func (q *Queries) CreateTreatmentRecommendation(ctx context.Context, db DBTX, arg *CreateTreatmentRecommendationParams) (*Treatmentrecommendation, error) {
	row := db.QueryRow(ctx, createTreatmentRecommendation,
		arg.ResultID,
		arg.SessionID,
		arg.DiagnosisID,
		arg.TreatmentOption,
		arg.Rationale,
		arg.Benefits,
		arg.Risks,
		arg.SideEffects,
		arg.Confidence,
	)
	var i Treatmentrecommendation
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.DiagnosisID,
		&i.TreatmentOption,
		&i.Rationale,
		&i.Benefits,
		&i.Risks,
		&i.SideEffects,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUploadedContent = `-- name: CreateUploadedContent :one

INSERT INTO uploadedcontent (session_id, content_type, file_path, study_data, content_data, findings, nodules)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING content_id, session_id, content_type, file_path, study_data, content_data, findings, nodules, created_at, updated_at
`

type CreateUploadedContentParams struct {
	SessionID   pgtype.UUID `json:"session_id"`
	ContentType ContentType `json:"content_type"`
	FilePath    string      `json:"file_path"`
	StudyData   []byte      `json:"study_data"`
	ContentData []byte      `json:"content_data"`
	Findings    []byte      `json:"findings"`
	Nodules     []byte      `json:"nodules"`
}

// ------------- UploadedContent Queries -------------
// CreateUploadedContent: Inserts a new uploaded content record.
func (q *Queries) CreateUploadedContent(ctx context.Context, db DBTX, arg *CreateUploadedContentParams) (*Uploadedcontent, error) {
	row := db.QueryRow(ctx, createUploadedContent,
		arg.SessionID,
		arg.ContentType,
		arg.FilePath,
		arg.StudyData,
		arg.ContentData,
		arg.Findings,
		arg.Nodules,
	)
	var i Uploadedcontent
	err := row.Scan(
		&i.ContentID,
		&i.SessionID,
		&i.ContentType,
		&i.FilePath,
		&i.StudyData,
		&i.ContentData,
		&i.Findings,
		&i.Nodules,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteAllImagesByPatientID = `-- name: DeleteAllImagesByPatientID :exec
DELETE FROM images
WHERE study_id IN (SELECT id FROM studies WHERE patient_id = $1)
`

// DeleteAllImagesByPatientID deletes all image records associated with a given patient ID.
func (q *Queries) DeleteAllImagesByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAllImagesByPatientID, patientID)
	return err
}

const deleteAllReportsByPatientID = `-- name: DeleteAllReportsByPatientID :exec
DELETE FROM reports
WHERE patient_id = $1
`

// DeleteAllReportsByPatientID deletes all reports for a patient
func (q *Queries) DeleteAllReportsByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAllReportsByPatientID, patientID)
	return err
}

const deleteAllStudiesByPatientID = `-- name: DeleteAllStudiesByPatientID :exec
DELETE FROM studies
WHERE patient_id = $1
`

// DeleteAllStudiesByPatientID deletes all studies for a patient
func (q *Queries) DeleteAllStudiesByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAllStudiesByPatientID, patientID)
	return err
}

const deleteAnalysisResult = `-- name: DeleteAnalysisResult :exec
DELETE FROM analysisresult
WHERE result_id = $1
`

// DeleteAnalysisResult: Deletes an analysis result by its ID.
func (q *Queries) DeleteAnalysisResult(ctx context.Context, db DBTX, resultID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAnalysisResult, resultID)
	return err
}

const deleteAnalysisResultBySessionID = `-- name: DeleteAnalysisResultBySessionID :exec
DELETE FROM analysisresult
WHERE session_id = $1
`

// DeleteAnalysisResultBySessionID: Deletes the analysis result for a session.
func (q *Queries) DeleteAnalysisResultBySessionID(ctx context.Context, db DBTX, sessionID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAnalysisResultBySessionID, sessionID)
	return err
}

const deleteAnalysisResultExternalResource = `-- name: DeleteAnalysisResultExternalResource :exec
DELETE FROM analysisresultexternalresource WHERE result_id = $1 and resource_id = $2
`

type DeleteAnalysisResultExternalResourceParams struct {
	ResultID   pgtype.UUID `json:"result_id"`
	ResourceID int32       `json:"resource_id"`
}

// DeleteAnalysisResultExternalResource: Removes a link between an analysis result and an external resource.
func (q *Queries) DeleteAnalysisResultExternalResource(ctx context.Context, db DBTX, arg *DeleteAnalysisResultExternalResourceParams) error {
	_, err := db.Exec(ctx, deleteAnalysisResultExternalResource, arg.ResultID, arg.ResourceID)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM patientsession
WHERE expiration_timestamp < NOW()
`

// DeleteExpiredSessions: Deletes expired patient sessions.
func (q *Queries) DeleteExpiredSessions(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteExternalResource = `-- name: DeleteExternalResource :exec
DELETE FROM externalresource
WHERE resource_id = $1
`

// DeleteExternalResource: Deletes an external resource by its ID.
func (q *Queries) DeleteExternalResource(ctx context.Context, db DBTX, resourceID int32) error {
	_, err := db.Exec(ctx, deleteExternalResource, resourceID)
	return err
}

const deleteImage = `-- name: DeleteImage :exec
DELETE FROM images
WHERE id = $1
`

// DeleteImage deletes a image by ID
func (q *Queries) DeleteImage(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteImage, id)
	return err
}

const deletePatientSession = `-- name: DeletePatientSession :exec
DELETE from patientsession
WHERE session_id = $1
`

// DeletePatientSession: Deletes a patient session by session ID.
func (q *Queries) DeletePatientSession(ctx context.Context, db DBTX, sessionID pgtype.UUID) error {
	_, err := db.Exec(ctx, deletePatientSession, sessionID)
	return err
}

const deletePrompt = `-- name: DeletePrompt :exec
DELETE
FROM prompts
WHERE prompt_id = $1
`

// DeletePrompt: Deletes a prompt by its ID.
func (q *Queries) DeletePrompt(ctx context.Context, db DBTX, promptID pgtype.UUID) error {
	_, err := db.Exec(ctx, deletePrompt, promptID)
	return err
}

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM reports
WHERE id = $1
`

// DeleteReport deletes a report by ID
func (q *Queries) DeleteReport(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteReport, id)
	return err
}

const deleteStudy = `-- name: DeleteStudy :exec
DELETE FROM studies
WHERE id = $1
`

// DeleteStudy deletes a study by ID
func (q *Queries) DeleteStudy(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteStudy, id)
	return err
}

const deleteUploadedContent = `-- name: DeleteUploadedContent :exec
DELETE FROM uploadedcontent
WHERE content_id = $1
`

// DeleteUploadedContent: Deletes uploaded content by its ID.
func (q *Queries) DeleteUploadedContent(ctx context.Context, db DBTX, contentID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteUploadedContent, contentID)
	return err
}

const deleteUploadedContentBySessionID = `-- name: DeleteUploadedContentBySessionID :exec
DELETE FROM uploadedcontent
WHERE session_id = $1
`

// DeleteUploadedContentBySessionID: Deletes all uploaded content for a session.
func (q *Queries) DeleteUploadedContentBySessionID(ctx context.Context, db DBTX, sessionID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteUploadedContentBySessionID, sessionID)
	return err
}

const getActivePrompt = `-- name: GetActivePrompt :one
SELECT prompt_id, description, template, input_variables, output_format, version, author, status, approval_status, created_at, updated_at
FROM prompts
WHERE description = $1
AND status = 'active'
ORDER BY version DESC
LIMIT 1
`

// GetActivePrompt: Retrieves the currently active prompt by description.
func (q *Queries) GetActivePrompt(ctx context.Context, db DBTX, description pgtype.Text) (*Prompt, error) {
	row := db.QueryRow(ctx, getActivePrompt, description)
	var i Prompt
	err := row.Scan(
		&i.PromptID,
		&i.Description,
		&i.Template,
		&i.InputVariables,
		&i.OutputFormat,
		&i.Version,
		&i.Author,
		&i.Status,
		&i.ApprovalStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAnalysisResultByID = `-- name: GetAnalysisResultByID :one
SELECT result_id, session_id, diagnosis, stage, treatment_recommendations, created_at, updated_at FROM analysisresult
WHERE result_id = $1
`

// GetAnalysisResultByID: Retrieves an analysis result by its ID.
func (q *Queries) GetAnalysisResultByID(ctx context.Context, db DBTX, resultID pgtype.UUID) (*Analysisresult, error) {
	row := db.QueryRow(ctx, getAnalysisResultByID, resultID)
	var i Analysisresult
	err := row.Scan(
		&i.ResultID,
		&i.SessionID,
		&i.Diagnosis,
		&i.Stage,
		&i.TreatmentRecommendations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAnalysisResultBySessionID = `-- name: GetAnalysisResultBySessionID :one
SELECT result_id, session_id, diagnosis, stage, treatment_recommendations, created_at, updated_at FROM analysisresult
WHERE session_id = $1
`

// GetAnalysisResultBySessionID: Retrieves the analysis result for a given session.
func (q *Queries) GetAnalysisResultBySessionID(ctx context.Context, db DBTX, sessionID pgtype.UUID) (*Analysisresult, error) {
	row := db.QueryRow(ctx, getAnalysisResultBySessionID, sessionID)
	var i Analysisresult
	err := row.Scan(
		&i.ResultID,
		&i.SessionID,
		&i.Diagnosis,
		&i.Stage,
		&i.TreatmentRecommendations,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at FROM auditlog
WHERE log_id = $1
`

// GetAuditLogByID: Retrieves an audit log entry by its ID.
func (q *Queries) GetAuditLogByID(ctx context.Context, db DBTX, logID int64) (*Auditlog, error) {
	row := db.QueryRow(ctx, getAuditLogByID, logID)
	var i Auditlog
	err := row.Scan(
		&i.LogID,
		&i.Timestamp,
		&i.Action,
		&i.Details,
		&i.SessionID,
		&i.ContentID,
		&i.ResultID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDiagnosisByID = `-- name: GetDiagnosisByID :one
SELECT id, result_id, session_id, diagnosis_text, confidence, justification, created_at, updated_at FROM diagnosis
WHERE id = $1
`

// GetDiagnosisByID retrieves a diagnosis by its ID.
func (q *Queries) GetDiagnosisByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Diagnosis, error) {
	row := db.QueryRow(ctx, getDiagnosisByID, id)
	var i Diagnosis
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.DiagnosisText,
		&i.Confidence,
		&i.Justification,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getExternalResourceByID = `-- name: GetExternalResourceByID :one
SELECT resource_id, name, url, description FROM externalresource
WHERE resource_id = $1
`

// GetExternalResourceByID: Retrieves an external resource by its ID.
func (q *Queries) GetExternalResourceByID(ctx context.Context, db DBTX, resourceID int32) (*Externalresource, error) {
	row := db.QueryRow(ctx, getExternalResourceByID, resourceID)
	var i Externalresource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Url,
		&i.Description,
	)
	return &i, err
}

const getImageByID = `-- name: GetImageByID :one
SELECT id, study_id, file_path, series_instance_uid, sop_instance_uid, image_type, content_data, created_at, updated_at FROM images
WHERE id = $1
`

// GetImageByID retrieves a image by its ID
func (q *Queries) GetImageByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Image, error) {
	row := db.QueryRow(ctx, getImageByID, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.StudyID,
		&i.FilePath,
		&i.SeriesInstanceUid,
		&i.SopInstanceUid,
		&i.ImageType,
		&i.ContentData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getImageByStudyID = `-- name: GetImageByStudyID :many
SELECT id, study_id, file_path, series_instance_uid, sop_instance_uid, image_type, content_data, created_at, updated_at FROM images
WHERE study_id = $1
`

// GetImageByStudyID retrieves all images for a study
func (q *Queries) GetImageByStudyID(ctx context.Context, db DBTX, studyID pgtype.UUID) ([]*Image, error) {
	rows, err := db.Query(ctx, getImageByStudyID, studyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.StudyID,
			&i.FilePath,
			&i.SeriesInstanceUid,
			&i.SopInstanceUid,
			&i.ImageType,
			&i.ContentData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoduleByID = `-- name: GetNoduleByID :one
SELECT finding_id, file_id, description, image_coordinates, source FROM findings WHERE finding_id = $1
`

type GetNoduleByIDRow struct {
	FindingID        pgtype.UUID `json:"finding_id"`
	FileID           pgtype.UUID `json:"file_id"`
	Description      string      `json:"description"`
	ImageCoordinates []float64   `json:"image_coordinates"`
	Source           string      `json:"source"`
}

// GetNoduleByID retrieves a nodule by its ID.
func (q *Queries) GetNoduleByID(ctx context.Context, db DBTX, findingID pgtype.UUID) (*GetNoduleByIDRow, error) {
	row := db.QueryRow(ctx, getNoduleByID, findingID)
	var i GetNoduleByIDRow
	err := row.Scan(
		&i.FindingID,
		&i.FileID,
		&i.Description,
		&i.ImageCoordinates,
		&i.Source,
	)
	return &i, err
}

const getPatientSessionByLink = `-- name: GetPatientSessionByLink :one
SELECT session_id, access_link, expiration_timestamp, used, patient_data, created_at, updated_at FROM patientsession
WHERE access_link = $1
`

// GetPatientSessionByLink: Retrieves a patient session by its access link.
func (q *Queries) GetPatientSessionByLink(ctx context.Context, db DBTX, accessLink string) (*Patientsession, error) {
	row := db.QueryRow(ctx, getPatientSessionByLink, accessLink)
	var i Patientsession
	err := row.Scan(
		&i.SessionID,
		&i.AccessLink,
		&i.ExpirationTimestamp,
		&i.Used,
		&i.PatientData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPromptByID = `-- name: GetPromptByID :one
SELECT prompt_id, description, template, input_variables, output_format, version, author, status, approval_status, created_at, updated_at
FROM prompts
WHERE prompt_id = $1
`

// GetPromptByID: Retrieves a prompt by its ID.
func (q *Queries) GetPromptByID(ctx context.Context, db DBTX, promptID pgtype.UUID) (*Prompt, error) {
	row := db.QueryRow(ctx, getPromptByID, promptID)
	var i Prompt
	err := row.Scan(
		&i.PromptID,
		&i.Description,
		&i.Template,
		&i.InputVariables,
		&i.OutputFormat,
		&i.Version,
		&i.Author,
		&i.Status,
		&i.ApprovalStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getReportByID = `-- name: GetReportByID :one
SELECT id, patient_id, filename, report_type, report_text, filepath, created_at, updated_at
FROM reports
WHERE id = $1
`

// GetReportByID retrieves a report by its ID.
func (q *Queries) GetReportByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Report, error) {
	row := db.QueryRow(ctx, getReportByID, id)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.Filename,
		&i.ReportType,
		&i.ReportText,
		&i.Filepath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getReportByPatientID = `-- name: GetReportByPatientID :many
SELECT id, patient_id, filename, report_type, report_text, filepath, created_at, updated_at
FROM reports
WHERE patient_id = $1
`

// GetReportByPatientID retrieves all reports for a patient
func (q *Queries) GetReportByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) ([]*Report, error) {
	rows, err := db.Query(ctx, getReportByPatientID, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.Filename,
			&i.ReportType,
			&i.ReportText,
			&i.Filepath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStageByID = `-- name: GetStageByID :one
SELECT id, result_id, session_id, t, n, m, confidence, created_at, updated_at
FROM stages
WHERE id = $1
`

// GetStageByID retrieves a staging record by its ID.
func (q *Queries) GetStageByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Stage, error) {
	row := db.QueryRow(ctx, getStageByID, id)
	var i Stage
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.T,
		&i.N,
		&i.M,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getStudyByID = `-- name: GetStudyByID :one
SELECT id, patient_id, study_instance_uid, study_data, created_at, updated_at FROM studies
WHERE id = $1
`

// GetStudyByID retrieves a study by its ID
func (q *Queries) GetStudyByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Study, error) {
	row := db.QueryRow(ctx, getStudyByID, id)
	var i Study
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.StudyInstanceUid,
		&i.StudyData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTreatmentRecommendationByID = `-- name: GetTreatmentRecommendationByID :one
SELECT id, result_id, session_id, diagnosis_id, treatment_option, rationale, benefits, risks, side_effects, confidence, created_at, updated_at
FROM treatmentrecommendations
WHERE id = $1
`

// GetTreatmentRecommendationByID retrieves a treatment recommendation record by its ID.
func (q *Queries) GetTreatmentRecommendationByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Treatmentrecommendation, error) {
	row := db.QueryRow(ctx, getTreatmentRecommendationByID, id)
	var i Treatmentrecommendation
	err := row.Scan(
		&i.ID,
		&i.ResultID,
		&i.SessionID,
		&i.DiagnosisID,
		&i.TreatmentOption,
		&i.Rationale,
		&i.Benefits,
		&i.Risks,
		&i.SideEffects,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUploadedContentByID = `-- name: GetUploadedContentByID :one
SELECT content_id, session_id, content_type, file_path, study_data, content_data, findings, nodules, created_at, updated_at FROM uploadedcontent
WHERE content_id = $1
`

// GetUploadedContentByID: Retrieves uploaded content by its ID.
func (q *Queries) GetUploadedContentByID(ctx context.Context, db DBTX, contentID pgtype.UUID) (*Uploadedcontent, error) {
	row := db.QueryRow(ctx, getUploadedContentByID, contentID)
	var i Uploadedcontent
	err := row.Scan(
		&i.ContentID,
		&i.SessionID,
		&i.ContentType,
		&i.FilePath,
		&i.StudyData,
		&i.ContentData,
		&i.Findings,
		&i.Nodules,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const invalidateLink = `-- name: InvalidateLink :exec
UPDATE patientsession
SET used = TRUE
WHERE access_link = $1
`

// InvalidateLink: Sets a link to used (effectively invalidating it).
func (q *Queries) InvalidateLink(ctx context.Context, db DBTX, accessLink string) error {
	_, err := db.Exec(ctx, invalidateLink, accessLink)
	return err
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at FROM auditlog
WHERE action = $1
ORDER BY timestamp DESC
`

// ListAuditLogsByAction: Retrieves all audit log entries for a specific action.
func (q *Queries) ListAuditLogsByAction(ctx context.Context, db DBTX, action string) ([]*Auditlog, error) {
	rows, err := db.Query(ctx, listAuditLogsByAction, action)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Auditlog
	for rows.Next() {
		var i Auditlog
		if err := rows.Scan(
			&i.LogID,
			&i.Timestamp,
			&i.Action,
			&i.Details,
			&i.SessionID,
			&i.ContentID,
			&i.ResultID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByContentID = `-- name: ListAuditLogsByContentID :many
SELECT log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at FROM auditlog
WHERE content_id = $1
ORDER BY timestamp DESC
`

// ListAuditLogsByContentID: Retrieves all audit log entries for a given content item.
func (q *Queries) ListAuditLogsByContentID(ctx context.Context, db DBTX, contentID pgtype.UUID) ([]*Auditlog, error) {
	rows, err := db.Query(ctx, listAuditLogsByContentID, contentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Auditlog
	for rows.Next() {
		var i Auditlog
		if err := rows.Scan(
			&i.LogID,
			&i.Timestamp,
			&i.Action,
			&i.Details,
			&i.SessionID,
			&i.ContentID,
			&i.ResultID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByResultID = `-- name: ListAuditLogsByResultID :many
SELECT log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at FROM auditlog
WHERE result_id = $1
ORDER BY timestamp DESC
`

// ListAuditLogsByResultID: Retrieves audit logs for a given analysis result
func (q *Queries) ListAuditLogsByResultID(ctx context.Context, db DBTX, resultID pgtype.UUID) ([]*Auditlog, error) {
	rows, err := db.Query(ctx, listAuditLogsByResultID, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Auditlog
	for rows.Next() {
		var i Auditlog
		if err := rows.Scan(
			&i.LogID,
			&i.Timestamp,
			&i.Action,
			&i.Details,
			&i.SessionID,
			&i.ContentID,
			&i.ResultID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsBySessionID = `-- name: ListAuditLogsBySessionID :many
SELECT log_id, timestamp, action, details, session_id, content_id, result_id, created_at, updated_at FROM auditlog
WHERE session_id = $1
ORDER BY timestamp DESC
`

// ListAuditLogsBySessionID: Retrieves all audit log entries for a given session.
func (q *Queries) ListAuditLogsBySessionID(ctx context.Context, db DBTX, sessionID pgtype.UUID) ([]*Auditlog, error) {
	rows, err := db.Query(ctx, listAuditLogsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Auditlog
	for rows.Next() {
		var i Auditlog
		if err := rows.Scan(
			&i.LogID,
			&i.Timestamp,
			&i.Action,
			&i.Details,
			&i.SessionID,
			&i.ContentID,
			&i.ResultID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExternalResources = `-- name: ListExternalResources :many
SELECT resource_id, name, url, description FROM externalresource
ORDER BY name
`

// ListExternalResources: Retrieves all external resources.
func (q *Queries) ListExternalResources(ctx context.Context, db DBTX) ([]*Externalresource, error) {
	rows, err := db.Query(ctx, listExternalResources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Externalresource
	for rows.Next() {
		var i Externalresource
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Url,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExternalResourcesByResultID = `-- name: ListExternalResourcesByResultID :many
SELECT er.resource_id, er.name, er.url, er.description
FROM externalresource er
         INNER JOIN analysisresultexternalresource ar ON er.resource_id = ar.resource_id
WHERE ar.result_id = $1
`

// ListExternalResourcesByResultID: Get all external resources associated with a given analysis result.
func (q *Queries) ListExternalResourcesByResultID(ctx context.Context, db DBTX, resultID pgtype.UUID) ([]*Externalresource, error) {
	rows, err := db.Query(ctx, listExternalResourcesByResultID, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Externalresource
	for rows.Next() {
		var i Externalresource
		if err := rows.Scan(
			&i.ResourceID,
			&i.Name,
			&i.Url,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImagesByPatientID = `-- name: ListImagesByPatientID :many
SELECT images.id, images.study_id, images.file_path, images.series_instance_uid, images.sop_instance_uid, images.image_type, images.content_data, images.created_at, images.updated_at
FROM images
INNER JOIN studies ON images.study_id = studies.id
WHERE studies.patient_id = $1
`

// ListImagesByPatientID retrieves all images for a patient
func (q *Queries) ListImagesByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) ([]*Image, error) {
	rows, err := db.Query(ctx, listImagesByPatientID, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Image
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.StudyID,
			&i.FilePath,
			&i.SeriesInstanceUid,
			&i.SopInstanceUid,
			&i.ImageType,
			&i.ContentData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrompts = `-- name: ListPrompts :many
SELECT prompt_id, description, template, input_variables, output_format, version, author, status, approval_status, created_at, updated_at
FROM prompts
ORDER BY description, version
`

// ListPrompts: Retrieves all prompts.
func (q *Queries) ListPrompts(ctx context.Context, db DBTX) ([]*Prompt, error) {
	rows, err := db.Query(ctx, listPrompts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Prompt
	for rows.Next() {
		var i Prompt
		if err := rows.Scan(
			&i.PromptID,
			&i.Description,
			&i.Template,
			&i.InputVariables,
			&i.OutputFormat,
			&i.Version,
			&i.Author,
			&i.Status,
			&i.ApprovalStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudiesByPatientID = `-- name: ListStudiesByPatientID :many
SELECT id, patient_id, study_instance_uid, study_data, created_at, updated_at FROM studies
WHERE patient_id = $1
`

// ListStudiesByPatientID retrieves all studies for a patient
func (q *Queries) ListStudiesByPatientID(ctx context.Context, db DBTX, patientID pgtype.UUID) ([]*Study, error) {
	rows, err := db.Query(ctx, listStudiesByPatientID, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Study
	for rows.Next() {
		var i Study
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.StudyInstanceUid,
			&i.StudyData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedContentBySessionID = `-- name: ListUploadedContentBySessionID :many
SELECT content_id, session_id, content_type, file_path, study_data, content_data, findings, nodules, created_at, updated_at FROM uploadedcontent
WHERE session_id = $1
ORDER BY created_at DESC
`

// ListUploadedContentBySessionID: Retrieves all uploaded content for a given session.
func (q *Queries) ListUploadedContentBySessionID(ctx context.Context, db DBTX, sessionID pgtype.UUID) ([]*Uploadedcontent, error) {
	rows, err := db.Query(ctx, listUploadedContentBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Uploadedcontent
	for rows.Next() {
		var i Uploadedcontent
		if err := rows.Scan(
			&i.ContentID,
			&i.SessionID,
			&i.ContentType,
			&i.FilePath,
			&i.StudyData,
			&i.ContentData,
			&i.Findings,
			&i.Nodules,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExternalResource = `-- name: UpdateExternalResource :one
UPDATE externalresource
SET name = $2, url = $3, description = $4
WHERE resource_id = $1
RETURNING resource_id, name, url, description
`

type UpdateExternalResourceParams struct {
	ResourceID  int32       `json:"resource_id"`
	Name        string      `json:"name"`
	Url         string      `json:"url"`
	Description pgtype.Text `json:"description"`
}

// UpdateExternalResource: Updates an existing external resource.
func (q *Queries) UpdateExternalResource(ctx context.Context, db DBTX, arg *UpdateExternalResourceParams) (*Externalresource, error) {
	row := db.QueryRow(ctx, updateExternalResource,
		arg.ResourceID,
		arg.Name,
		arg.Url,
		arg.Description,
	)
	var i Externalresource
	err := row.Scan(
		&i.ResourceID,
		&i.Name,
		&i.Url,
		&i.Description,
	)
	return &i, err
}

const updatePatientSessionUsed = `-- name: UpdatePatientSessionUsed :exec
UPDATE patientsession
SET used = TRUE
WHERE session_id = $1
`

// UpdatePatientSessionUsed: Marks a patient session as used.
func (q *Queries) UpdatePatientSessionUsed(ctx context.Context, db DBTX, sessionID pgtype.UUID) error {
	_, err := db.Exec(ctx, updatePatientSessionUsed, sessionID)
	return err
}

const updatePrompt = `-- name: UpdatePrompt :one
UPDATE prompts
SET description     = $2,
	template        = $3,
	input_variables = $4,
	output_format   = $5,
	version         = $6,
	author          = $7,
	status          = $8,
	approval_status = $9
WHERE prompt_id = $1
RETURNING prompt_id, description, template, input_variables, output_format, version, author, status, approval_status, created_at, updated_at
`

type UpdatePromptParams struct {
	PromptID       pgtype.UUID `json:"prompt_id"`
	Description    pgtype.Text `json:"description"`
	Template       string      `json:"template"`
	InputVariables pgtype.Text `json:"input_variables"`
	OutputFormat   pgtype.Text `json:"output_format"`
	Version        string      `json:"version"`
	Author         pgtype.Text `json:"author"`
	Status         string      `json:"status"`
	ApprovalStatus pgtype.Text `json:"approval_status"`
}

// UpdatePrompt: Updates an existing prompt.
func (q *Queries) UpdatePrompt(ctx context.Context, db DBTX, arg *UpdatePromptParams) (*Prompt, error) {
	row := db.QueryRow(ctx, updatePrompt,
		arg.PromptID,
		arg.Description,
		arg.Template,
		arg.InputVariables,
		arg.OutputFormat,
		arg.Version,
		arg.Author,
		arg.Status,
		arg.ApprovalStatus,
	)
	var i Prompt
	err := row.Scan(
		&i.PromptID,
		&i.Description,
		&i.Template,
		&i.InputVariables,
		&i.OutputFormat,
		&i.Version,
		&i.Author,
		&i.Status,
		&i.ApprovalStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
