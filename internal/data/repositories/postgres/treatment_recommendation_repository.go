// internal/data/repositories/postgres/treatment_recommendation_repository.go
package postgres

import (
	"context"
	"errors"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stackvity/lung-server/internal/data/models"
	"github.com/stackvity/lung-server/internal/data/repositories/interfaces"
	postgres "github.com/stackvity/lung-server/internal/data/repositories/sqlc" // Alias for sqlc-generated code package
	"github.com/stackvity/lung-server/internal/domain"
	"github.com/stackvity/lung-server/internal/utils"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var _ interfaces.TreatmentRecommendationRepository = (*TreatmentRecommendationRepository)(nil)

// TreatmentRecommendationRepository implements interfaces.TreatmentRecommendationRepository for PostgreSQL.
// This repository provides a concrete implementation for accessing and managing TreatmentRecommendation data
// within a PostgreSQL database, adhering to the repository pattern for data access abstraction.
type TreatmentRecommendationRepository struct {
	db      *pgxpool.Pool
	queries *postgres.Queries // queries: Embeds the generated Queries struct from sqlc for type-safe database interactions.
	logger  *zap.Logger
}

// NewTreatmentRecommendationRepository creates a new TreatmentRecommendationRepository instance.
// It initializes the repository with a pgxpool.Pool for database connectivity and a zap.Logger for structured logging.
// It is designed to be used with dependency injection, ensuring proper setup and configuration.
func NewTreatmentRecommendationRepository(db *pgxpool.Pool, logger *zap.Logger) *TreatmentRecommendationRepository {
	return &TreatmentRecommendationRepository{
		db:      db,
		queries: postgres.New(), // queries: Initialize sqlc generated Queries for query execution.
		logger:  logger,
	}
}

// CreateTreatmentRecommendation implements interfaces.TreatmentRecommendationRepository.
// CreateTreatmentRecommendation inserts a new treatment recommendation record into the database.
// It takes a context for cancellation and timeout, and a pointer to a models.TreatmentRecommendation object
// containing the data to be persisted.
// Returns an error if the insertion fails, otherwise nil, indicating successful creation.
func (r *TreatmentRecommendationRepository) CreateTreatmentRecommendation(ctx context.Context, treatmentRecommendation *models.TreatmentRecommendation) error {
	const operation = "postgres.TreatmentRecommendationRepository.CreateTreatmentRecommendation" // Define operation name for consistent logging
	requestID := utils.GetRequestID(ctx.(*gin.Context))                                          // Extract request ID from context for request tracing

	r.logger.Debug("Starting DB operation: CreateTreatmentRecommendation", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendation.ID.String()), zap.String("request_id", requestID))

	params := &postgres.CreateTreatmentRecommendationParams{ // Use params struct generated by sqlc for type safety and parameter mapping
		ResultID:        pgtype.UUID{Bytes: uuid.UUID(treatmentRecommendation.ResultID), Valid: true},
		SessionID:       pgtype.UUID{Bytes: uuid.UUID(treatmentRecommendation.SessionID), Valid: true},
		DiagnosisID:     pgtype.UUID{Bytes: uuid.UUID(treatmentRecommendation.DiagnosisID), Valid: true},
		TreatmentOption: pgtype.Text{String: treatmentRecommendation.TreatmentOption, Valid: true},
		Rationale:       pgtype.Text{String: treatmentRecommendation.Rationale, Valid: true},
		Benefits:        pgtype.Text{String: treatmentRecommendation.Benefits, Valid: true},
		Risks:           pgtype.Text{String: treatmentRecommendation.Risks, Valid: true},
		SideEffects:     pgtype.Text{String: treatmentRecommendation.SideEffects, Valid: true},
		Confidence:      pgtype.Text{String: treatmentRecommendation.Confidence, Valid: true},
	}

	// Conditionally log parameters at debug level for detailed insight during development and debugging.
	if r.logger.Core().Enabled(zapcore.DebugLevel) {
		r.logger.Debug("DB parameters", zap.String("operation", operation), zap.String("request_id", requestID), zap.Any("params", params))
	}

	_, err := r.queries.CreateTreatmentRecommendation(ctx, r.db, params) // Execute the sqlc-generated query for database insertion
	if err != nil {
		r.logger.Error("DB error in CreateTreatmentRecommendation", zap.String("operation", operation), zap.String("request_id", requestID), zap.Error(err))
		return utils.NewErrDBQuery("CreateTreatmentRecommendation failed", operation, "CreateTreatmentRecommendation", params, err) // Enhanced error wrapping for context and operation details
	}

	r.logger.Debug("Successfully completed DB operation", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendation.ID.String()), zap.String("request_id", requestID))
	return nil
}

// GetTreatmentRecommendationByID implements interfaces.TreatmentRecommendationRepository.
// GetTreatmentRecommendationByID retrieves a treatment recommendation record by its unique ID from the database.
// It takes a context and the treatmentRecommendationID (UUID) as input to identify the database record.
// Returns a populated models.TreatmentRecommendation object if the record is found.
// Returns a domain.NotFoundError if the record is not found, or another error if the retrieval fails.
func (r *TreatmentRecommendationRepository) GetTreatmentRecommendationByID(ctx context.Context, treatmentRecommendationID uuid.UUID) (*models.TreatmentRecommendation, error) {
	const operation = "postgres.TreatmentRecommendationRepository.GetTreatmentRecommendationByID"
	requestID := utils.GetRequestID(ctx.(*gin.Context))
	r.logger.Debug("Starting DB operation", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendationID.String()), zap.String("request_id", requestID))

	treatmentRecommendation, err := r.queries.GetTreatmentRecommendationByID(ctx, r.db, pgtype.UUID{Bytes: uuid.UUID(treatmentRecommendationID), Valid: true})
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			r.logger.Warn("TreatmentRecommendation not found in database", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendationID.String()), zap.String("request_id", requestID), zap.Error(err))
			return nil, domain.NewNotFoundError("treatmentRecommendation", treatmentRecommendationID.String()) // Return domain-specific NotFoundError for explicit handling in service layer
		}
		r.logger.Error("DB error in GetTreatmentRecommendationByID", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendationID.String()), zap.String("request_id", requestID), zap.Error(err))
		dbErr := utils.NewErrDBQuery("GetTreatmentRecommendationByID failed", operation, "GetTreatmentRecommendationByID", treatmentRecommendationID.String(), err) // Enhanced error wrapping for detailed error context
		if setLoggerErr, ok := dbErr.(interface{ SetLogger(*zap.Logger) }); ok {
			setLoggerErr.SetLogger(r.logger) // Set logger for enhanced error reporting in domain-level error
		}
		return nil, dbErr
	}

	// Map the sqlc-generated struct (database representation) to the domain model struct (application representation)
	// for data consistency and decoupling between data access layer and domain layer.
	modelTreatmentRecommendation := &models.TreatmentRecommendation{
		ID:              uuid.UUID(treatmentRecommendation.ID.Bytes),
		ResultID:        uuid.UUID(treatmentRecommendation.ResultID.Bytes),
		SessionID:       uuid.UUID(treatmentRecommendation.SessionID.Bytes),
		DiagnosisID:     uuid.UUID(treatmentRecommendation.DiagnosisID.Bytes),
		TreatmentOption: treatmentRecommendation.TreatmentOption.String,
		Rationale:       treatmentRecommendation.Rationale.String,
		Benefits:        treatmentRecommendation.Benefits.String,
		Risks:           treatmentRecommendation.Risks.String,
		SideEffects:     treatmentRecommendation.SideEffects.String,
		Confidence:      treatmentRecommendation.Confidence.String,
		CreatedAt:       treatmentRecommendation.CreatedAt.Time,
		UpdatedAt:       treatmentRecommendation.UpdatedAt.Time,
	}

	r.logger.Debug("Successfully completed DB operation", zap.String("operation", operation), zap.String("treatment_recommendation_id", treatmentRecommendationID.String()), zap.String("request_id", requestID))
	return modelTreatmentRecommendation, nil
}

// DeleteAllTreatmentRecommendationsByPatientID implements interfaces.TreatmentRecommendationRepository.
// Currently, explicit deletion is not implemented here, relying on cascade delete from session.
// This function is kept to explicitly document this behavior and for potential future implementation
// of custom deletion logic if cascade delete is insufficient or needs to be overridden.
func (r *TreatmentRecommendationRepository) DeleteAllTreatmentRecommendationsByPatientID(ctx context.Context, patientID uuid.UUID) error {
	const operation = "postgres.TreatmentRecommendationRepository.DeleteAllTreatmentRecommendationsByPatientID"
	requestID := utils.GetRequestID(ctx.(*gin.Context))
	r.logger.Debug("Starting DB operation", zap.String("operation", operation), zap.String("patient_id", patientID.String()), zap.String("request_id", requestID))

	// In the current database schema, treatment recommendations are linked to analysis_result,
	// which in turn has a cascade delete to patient_session. Therefore, explicit deletion of treatment recommendations
	// within this repository method is redundant and unnecessary, as deleting the patient session will automatically
	// delete associated treatment recommendations due to the ON DELETE CASCADE constraint defined in the database schema.
	r.logger.Warn("DeleteAllTreatmentRecommendationsByPatientID: Explicit deletion of treatment recommendations is not implemented in code. Deletion is implicitly handled by database cascade delete through analysis_result to patient_session.", zap.String("operation", operation), zap.String("patient_id", patientID.String()), zap.String("request_id", requestID))
	return nil // No explicit deletion action taken, relying on cascade delete. Return nil to indicate successful (no-op) execution.
}

// BeginTx implements interfaces.Repository.
// BeginTx starts a new database transaction, providing atomicity and isolation for database operations.
// It accepts a context for cancellation and timeout, and optional pgx.TxOptions to configure transaction behavior,
// allowing for customization of transaction properties like isolation level and access mode.
func (r *TreatmentRecommendationRepository) BeginTx(ctx context.Context, opts ...pgx.TxOptions) (pgx.Tx, error) {
	requestID := utils.GetRequestID(ctx.(*gin.Context)) // Get request ID for logging context
	r.logger.Debug("Starting transaction", zap.String("operation", "postgres.TreatmentRecommendationRepository.BeginTx"), zap.String("request_id", requestID))
	if len(opts) > 0 {
		return r.db.BeginTx(ctx, opts[0]) // Begin transaction with provided options, if any are passed
	}
	return r.db.Begin(ctx) // Begin transaction with default transaction options if no options are provided
}

// CommitTx implements interfaces.Repository.
// CommitTx commits the database transaction, persisting all changes made within the transaction to the database.
// It takes a context and the pgx.Tx transaction object representing the active transaction.
// Returns an error if the commit operation fails, indicating that the transaction could not be successfully committed.
func (r *TreatmentRecommendationRepository) CommitTx(ctx context.Context, tx pgx.Tx) error {
	requestID := utils.GetRequestID(ctx.(*gin.Context)) // Get request ID for logging context
	r.logger.Debug("Commiting transaction", zap.String("operation", "postgres.TreatmentRecommendationRepository.CommitTx"), zap.String("request_id", requestID))
	return tx.Commit(ctx)
}

// RollbackTx implements interfaces.Repository.
// RollbackTx rolls back the database transaction, discarding all changes made within the transaction and reverting the database to its state before the transaction began.
// It takes a context and the pgx.Tx transaction object representing the active transaction.
// Returns an error if the rollback operation fails, indicating that the transaction could not be successfully rolled back.
func (r *TreatmentRecommendationRepository) RollbackTx(ctx context.Context, tx pgx.Tx) error {
	requestID := utils.GetRequestID(ctx.(*gin.Context)) // Get request ID for logging context
	r.logger.Debug("Rolling back transaction", zap.String("operation", "postgres.TreatmentRecommendationRepository.RollbackTx"), zap.String("request_id", requestID))
	return tx.Rollback(ctx)
}
